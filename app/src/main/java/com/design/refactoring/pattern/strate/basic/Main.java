package com.design.refactoring.pattern.strate.basic;

/**
 * 스트레티지 패턴 : 같은 문제를 해결하는 여러 알고리즘(방식)이 클래스별로
 * 캡슐화되어 있고, 이들이 필요할 때 교체할 수 있도록 함으로써
 * 동일한 문제를 다른 알고리즘으로 해결할 수 있게 한다.
 *
 * 즉, 객체가 할 수 있는 행위 각각에 대한 전략 클래스를 생성하여
 * 객체의 행위를 동적으로 바꾸고 싶을때, 직접 행위를 수정하지 않고 전략을 바꿔준다.
 *
 * 참고 : JAVA 객체지향 디자인패턴 6장
 */
public class Main {
    public static void main(String[] args) {
        Moving bus = new Bus();
        Moving train = new Train();

        bus.setMovableStrategy(new LoadStrategy());
        train.setMovableStrategy(new RailStrategy());

        bus.move();
        train.move();

        // 버스가 선로로 이동하도록 변경하기
        bus.setMovableStrategy(new RailStrategy());
        bus.move();
    }
}

// 사용 예1) 1. 회원은 이름과 누적 대여 금액을 갖는다.
//          2.  책은 서명, 출판년도, 가격을 갖는다 (재고는 무한대라고 가정)
//          3. 회원은 하나의 책을 1권 이상 살 수 있다.
//          4. 회원이 책을 살 때마다 누적 금액이 저장된다.
//          5. 가격 정책에 따라 책 값이 할인되며, 다른 가격 정책이 추가될 수 있다.
//          6. 10년 이상 된 책은 책 자체 할인, 누적 대여 금액이 만 원 이상이면 회원 할인, 그 외의 경우에는 할인이 없다.
//          => 이 경우 ① 10년 이상 되었을때의 할인 정책, ② 누적 대여 금액이 만원 이상일때의 할인 정책, ③ 할인이 없을때의 정책
//             세가지의 Strategy 클래스를 만들어 개발할 수 있다.
//          => 인터페이스 내부에 들어갈 메소드인 행위는 정책에 따른 가격 계산일 것이다.

// 사용 예2) 1. 필드 안에 2개 이상의 공이 존재한다.
//          2. 각 공은 첫째, 좌우로 움직이거나 둘째, 상하로 움직이거나 셋째, 대각선으로 움직일 수 있다.
//          3. 각 공은 빨간색이나 파란색으로 칠해진다.
//          => 이 경우 ① 좌우로 움직일때의 정책, ② 상하로 움직일때의 정책, ③ 대각선으로 움직일때의 정책
//             세가지의 Strategy 클래스를 만들어 개발할 수 있다.
//          => 인터페이스 내부에 들어갈 메소드인 행위는 움직임(Move) 일 것이다.