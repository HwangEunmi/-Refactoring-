package com.design.refactoring.pattern.state.deepening;

/**
 * 메인 클래스 (Client 클래스)
 */
public class Client {

    public static void main(String[] args) {

        // 음료의 가격은 1000원이며 재고는 5개이다.
        JuiceMachine machine = new JuiceMachine(1000, 5);

        machine.insertMoney(1000); // 돈을 1000원 넣는다. (현재금액 1000원)
        machine.insertMoney(500); // 돈을 500원 넣는다. (현재금액 1500원)
        machine.pushButton(); // 음료수를 뽑는다. (현재금액 500원)
        machine.returnMoney(); // 돈을 반환한다. (현재금액 0원)

        machine.insertMoney(1000); // 돈을 1000원 넣는다. (현재금액 1000원)
        machine.insertMoney(1000); // 돈을 1000원 넣는다. (현재금액 2000원)
        machine.pushButton(); // 음료수를 뽑는다. (현재금액 1000원)

    }

}

// 사용 예2) 1. 자판기에 돈을 넣고 버튼을 누르면 음료수를 뽑을 수 있다.
//          2. 거스름돈이나 현재 넣은 돈을 반환할 수 있으며 반환한 돈의 액수를 출력한다.
//          3. 음료의 가격과 재고를 지정할 수 있다.
//          4. 돈을 넣으면 현재 넣은 돈의 총합을 출력한다.
//          5. 돈이 없을때 음료 버튼이나 반환 버튼이 눌려지면 에러 메시지를 출력한다.
//          6. 돈이 있어도 음료 가격보다 돈의 액수가 적으면 음료를 뽑을 수 없으며 에러 메시지를 출력한다.
//          7. 재고가 있고 음료 가격 이상의 돈이 있을때 음료를 뽑을 수 있다.
//          8. 음료가 매진되었을 경우 돈이 투입되면 곧바로 반환하고 에러 메시지를 출력한다.
//          9. 음료가 매진되었을 경우 버튼이 눌려지면 에러메시지를 출력한다.
//          => 이 경우 ① 돈이 없는 상태, ② 돈이 부족한 상태, ③ 돈이 충분한 상태, ④ 음료가 매진된 상태
//             네가지의 상태로 나눌 수 있다.
//          => 인터페이스 내부에 들어갈 메소드인 행위는 ① 돈을 투입하기, ② 버튼을 누르기, ③ 돈을 반환하기  일 것이다.